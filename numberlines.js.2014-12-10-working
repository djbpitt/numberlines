"use strict";
/*
 * numberlines.js
 * Numbers lines in <pre> blocks automatically; works with numberlines.css
 * David J. Birnbaum, djbpitt@gmail.com, http://www.obdurodon.org
 * 2014-11-16 Initial version
 * 2014-11-18 Change from load event to DOMContentLoaded; reduces FOUT
 * 2014-12-06
 * 2014-12-10 Retrieves color from parent span if there is one
 *   Does not look higher in tree
 *   Does not retrieve other style properties
 *   Uses @class instead of @id to attach; reset numbering in CSS to support multiples
 *   Fixes (well, fakes) height of container <pre> vertical spacing
 *
 * To do:
 *   Add horizontal scrolling that doesn't intrude into padding (nested <div> elements?)
 *   Use private namespace or anonymous functions
 *
 * Revision of http://bililite.com/blog/2012/08/05/line-numbering-in-pre-elements/
 * Additional information about JavaScript ranges
 *   By (whom else?!) PPK at http://www.quirksmode.org/dom/range_intro.html
 *   At https://developer.mozilla.org/en-US/docs/Web/API/Range
 * documentFragment based on http://ejohn.org/blog/dom-documentfragments/
 */
function processBlocks() {
    var blocks = document.getElementsByClassName('block');
    for (var i = 0; i < blocks.length; i++) {
        numberLines(blocks[i]);
    }
}
function numberLines(block) {
    var range = document.createRange(),
        rebuilt = document.createDocumentFragment(),
        span,
        fragment,
        startPos = 0,
        endPos = 0,
        startParent,
        endParent,
        startNode,
        startOffset,
        endNode,
        endOffset,
        lines,
        i;
    lines = block.textContent.split('\n');
    for (i = 0; i < lines.length; i++) {
        endPos = startPos + lines[i].length;
        startParent = getParentNode(block, startPos, 'start');
        startNode = startParent['startNode'];
        startOffset = startParent['startOffset'];
        endParent = getParentNode(block,endPos,'end');
        endNode = endParent['endNode'];
        endOffset = endParent['endOffset'];
        range.setStart(startNode,startOffset);
        range.setEnd(endNode,endOffset);
        span = document.createElement('span');
        // if they share a non-pre parent, get its color
        // A more robust solution would get other properties, and would look all the way up the tree
        if (startNode.parentNode.nodeName != 'pre' && startNode.parentNode === endNode.parentNode) {
            span.style.color = startNode.parentNode.style.color;
        }
        fragment = range.cloneContents();
        span.appendChild(fragment);
        rebuilt.appendChild(span);
        startPos += lines[i].length + 1;
    }
    block.innerHTML = "";
    block.appendChild(rebuilt.cloneNode(true));
    block.style.height=(lines.length * 1.05) + 'em';
}
function getParentNode(root, targetPosition, anchor) {
    /*
     * position = character offset of beginning of node currently being searched
     * targetPosition = character offset of beginning or end of line currently being formatted
     * anchor = ('start'|'end') (of line currently being formatted)
     * */
    var nodeIterator = document.createNodeIterator(root, NodeFilter.SHOW_TEXT);
    var currentNode;
    var currentNodeOffset;
    var position = 0;
    var nodeLength;
    while (currentNode = nodeIterator.nextNode()) {
        nodeLength = currentNode.nodeValue.length;
        if (position <= targetPosition && targetPosition <= (position + currentNode.nodeValue.length)) {
            currentNodeOffset = targetPosition - position;
            if (anchor == 'start') {
                return {startNode : currentNode, startOffset : currentNodeOffset};
            } else {
                return {endNode : currentNode, endOffset : currentNodeOffset};
            }
        }
        position += nodeLength;
    }
}
window.addEventListener('load', processBlocks, false);