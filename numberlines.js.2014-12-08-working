"use strict";
/*
 * numberlines.js
 * Numbers lines in <pre> blocks automatically; works with numberlines.css
 * David J. Birnbaum, djbpitt@gmail.com, http://www.obdurodon.org
 * 2014-11-16 Initial version
 * 2014-11-18 Change from load event to DOMContentLoaded; reduces FOUT
 * 2014-12-06
 *   Use @class instead of @id to attach; reset numbering in CSS to support multiples
 *
 * To do:
 *   Use ranges to preserve internal markup
 *   Add horizontal scrolling that doesn't intrude into padding (nested <div> elements?)
 *   Fix vertical padding (also solved by nested <div> elements?)
 *   Use private namespace or anonymous functions
 *
 * Revision of http://bililite.com/blog/2012/08/05/line-numbering-in-pre-elements/
 * Additional information about JavaScript ranges
 *   By (whom else?!) PPK at http://www.quirksmode.org/dom/range_intro.html
 *   At https://developer.mozilla.org/en-US/docs/Web/API/Range
 * documentFragment based on http://ejohn.org/blog/dom-documentfragments/
 */
function processBlocks() {
    var blocks = document.getElementsByClassName('block');
    for (var i = 0; i < blocks.length; i++) {
        numberLines(blocks[i]);
    }
}
function numberLines(block) {
    var range = document.createRange(),
        rebuilt = document.createDocumentFragment(),
        span,
        height,
        fragment,
        startPos = 0,
        endPos = 0,
        startParent,
        endParent,
        startNode,
        startOffset,
        endNode,
        endOffset,
        lines,
        i;
    /*
     * Finds <pre> with @class of 'numberedBlock', splits into lines, wraps <span> tags around
     * the lines, replaces original <pre> contents with lines all tagged as <span>
     */
    height = window.getComputedStyle(block).getPropertyValue('height');
    console.log(height);
    lines = block.textContent.split('\n');
    for (i = 0; i < lines.length; i++) {
        endPos = startPos + lines[i].length;
        //console.log('\nline textContent: ' + lines[i]);
        //console.log('Line starts at offset ' + startPos);
        startParent = getParentNode(block, startPos, 'start');
        startNode = startParent['startNode'];
        startOffset = startParent['startOffset'];
        endParent = getParentNode(block,endPos,'end');
        endNode = endParent['endNode'];
        endOffset = endParent['endOffset'];
        range.setStart(startNode,startOffset);
        range.setEnd(endNode,endOffset);
        span = document.createElement('span');
        fragment = range.cloneContents();
        span.appendChild(fragment);
        rebuilt.appendChild(span);
        //console.log(fragment);
        //console.log('Back:\n' + 'startNode = ' + startNode.nodeName + ' and startOffset = ' + startOffset +
        //    '\nendNode = ' + endNode.nodeName + ' and endOffset = ' + endOffset);
        startPos += lines[i].length + 1;
    }
    //console.log(rebuilt);
    block.innerHTML = "";
    block.appendChild(rebuilt.cloneNode(true));
    block.style.height = height;
}
function getParentNode(root, targetPosition, anchor) {
    /*
     * position = character offset of beginning of node currently being searched
     * targetPosition = character offset of beginning or end of line currently being formatted
     * anchor = ('start'|'end') (of line currently being formatted)
     * */
    var nodeIterator = document.createNodeIterator(root, NodeFilter.SHOW_TEXT);
    var currentNode;
    var currentNodeType;
    var currentNodeOffset;
    var position = 0;
    var nodeLength;
    while (currentNode = nodeIterator.nextNode()) {
        nodeLength = currentNode.nodeValue.length;
        if (anchor == 'start') {
            if (position <= targetPosition && targetPosition <= (position + currentNode.nodeValue.length)) {
                currentNodeType = (currentNode.parentNode.nodeName == 'pre') ? currentNode.nodeType : currentNode.parentNode.nodeType ;
                currentNodeOffset = targetPosition - position;
                //console.log('Hit: This node of type ' + currentNodeType + ' starts at ' + position +
                //' characters into the block and ends at ' + (position + currentNode.nodeValue.length) + ' characters into the block');
                //console.log('Offset into node = ' + currentNodeOffset);
                return {startNode : currentNode, startOffset : currentNodeOffset};
            }
            position += nodeLength;
        } else {
            if (position <= targetPosition && targetPosition <= (position + currentNode.nodeValue.length)) {
                currentNodeType = (currentNode.parentNode.nodeName == 'pre') ? currentNode.nodeType : currentNode.parentNode.nodeType ;
                currentNodeOffset = targetPosition - position;
                //console.log('Hit: The node of type ' + currentNodeType + ' starts at ' + position +
                //' characters into the block and ends at ' + (position + currentNode.nodeValue.length) + ' characters into the block');
                //console.log('Offset into node = ' + currentNodeOffset);
                return {endNode : currentNode, endOffset : currentNodeOffset};
            }
            position += nodeLength;
        }
    }
}
window.addEventListener('DOMContentLoaded', processBlocks, false);